#!/bin/bash
apt update
apt install qrencode curl jq -y

# УЛУЧШЕННАЯ НАСТРОЙКА BBR ДЛЯ МАЛОМОЩНЫХ VPS
echo "Настройка оптимизированного BBR для 1GB RAM VPS..."

# Проверяем текущие настройки
bbr_status=$(sysctl -a 2>/dev/null | grep net.ipv4.tcp_congestion_control | awk '{print $3}')

if [ "$bbr_status" = "bbr" ]; then
    echo "BBR уже включен"
else
    # Очищаем старые настройки
    sed -i '/net.core.default_qdisc/d' /etc/sysctl.conf
    sed -i '/net.ipv4.tcp_congestion_control/d' /etc/sysctl.conf
    sed -i '/net.ipv4.tcp_fastopen/d' /etc/sysctl.conf
    sed -i '/net.core.rmem_max/d' /etc/sysctl.conf
    sed -i '/net.core.wmem_max/d' /etc/sysctl.conf
    sed -i '/net.ipv4.tcp_rmem/d' /etc/sysctl.conf
    sed -i '/net.ipv4.tcp_wmem/d' /etc/sysctl.conf
    
    # ОПТИМИЗИРОВАННЫЕ НАСТРОЙКИ ДЛЯ 1GB RAM
    cat << 'SYSCTL' >> /etc/sysctl.conf
# BBR Congestion Control
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr

# TCP Fast Open
net.ipv4.tcp_fastopen = 3

# Buffer sizes optimized for 1GB RAM
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
net.core.rmem_default = 131072
net.core.wmem_default = 131072

# TCP memory settings
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
net.ipv4.tcp_mem = 786432 1048576 1572864

# TCP optimization
net.ipv4.tcp_slow_start_after_idle = 0
net.ipv4.tcp_max_syn_backlog = 65536
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_syn_retries = 3
net.ipv4.tcp_retries2 = 8

# Keepalive settings
net.ipv4.tcp_keepalive_time = 300
net.ipv4.tcp_keepalive_probes = 5
net.ipv4.tcp_keepalive_intvl = 15

# Network performance
net.core.netdev_max_backlog = 65536
net.core.somaxconn = 65535
net.ipv4.tcp_max_tw_buckets = 1440000
net.ipv4.tcp_tw_reuse = 1
SYSCTL

    # Применяем настройки
    sysctl -p
    echo "✅ Оптимизированный BBR включен для 1GB RAM VPS"
fi

# Дополнительная оптимизация для NVMe
if lsblk | grep -q nvme; then
    echo "Обнаружен NVMe диск - применяем дополнительные оптимизации..."
    # Оптимизация I/O для NVMe
    echo 'vm.swappiness = 10' >> /etc/sysctl.conf
    echo 'vm.dirty_ratio = 15' >> /etc/sysctl.conf
    echo 'vm.dirty_background_ratio = 5' >> /etc/sysctl.conf
    sysctl -p
fi

# ОПТИМИЗАЦИЯ СИСТЕМЫ ДЛЯ VPS
echo "Применение системных оптимизаций..."

# Увеличиваем лимиты файлов для большого количества соединений
sed -i '/^\*.*soft.*nofile/d' /etc/security/limits.conf
sed -i '/^\*.*hard.*nofile/d' /etc/security/limits.conf
echo '* soft nofile 65535' >> /etc/security/limits.conf
echo '* hard nofile 65535' >> /etc/security/limits.conf

# Оптимизация для systemd services
mkdir -p /etc/systemd/system.conf.d/
cat << 'SYSTEMD' > /etc/systemd/system.conf.d/limits.conf
[Manager]
DefaultLimitNOFILE=65535
DefaultTasksMax=65535
SYSTEMD

# Перезагружаем systemd
systemctl daemon-reload

# Убедимся что geosite.dat и geoip.dat существуют
mkdir -p /usr/local/share/xray
cd /usr/local/share/xray

# Скачаем актуальные geo-файлы если их нет
if [ ! -f "geosite.dat" ] || [ ! -f "geoip.dat" ]; then
    echo "Скачиваем актуальные geo-файлы..."
    wget -q -O geoip.dat https://github.com/Loyalsoldier/v2ray-rules-dat/releases/latest/download/geoip.dat
    wget -q -O geosite.dat https://github.com/Loyalsoldier/v2ray-rules-dat/releases/latest/download/geosite.dat
    echo "✅ Geo-файлы обновлены"
fi

# Swap: 2 ГБ если RAM ≤ 1 ГБ и swap отсутствует
setup_swap_if_needed() {
    local ram_kb ram_mb
    ram_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    ram_mb=$((ram_kb / 1024))

    # Проверяем, есть ли уже активный swap
    if swapon --show | grep -q .; then
        echo "info: swap уже активен, пропускаем."
        return 0
    fi

    # Если /swapfile существует, но не активен — активируем его
    if [ -f /swapfile ]; then
        echo "info: /swapfile найден, активируем..."
        swapon /swapfile
        return 0
    fi

    # Создаём swap только если RAM ≤ 1 ГБ
    if [ "$ram_mb" -le 1024 ]; then
        echo "info: RAM = ${ram_mb} MB ≤ 1024 MB — создаём swap 2 ГБ..."
        if fallocate -l 2G /swapfile >/dev/null 2>&1; then
            :
        else
            # fallback для файловых систем, не поддерживающих fallocate
            echo "info: fallocate недоступен, используем dd..."
            dd if=/dev/zero of=/swapfile bs=1M count=2048 status=none 2>/dev/null
        fi
        chmod 600 /swapfile
        mkswap /swapfile >/dev/null 2>&1
        swapon /swapfile
        echo '/swapfile none swap sw 0 0' >> /etc/fstab
        echo "info: swap 2 ГБ успешно создан и активирован."
    else
        echo "info: RAM = ${ram_mb} MB > 1024 MB — swap не требуется."
    fi
}

# ВЫЗЫВАЕМ ФУНКЦИЮ создания swap
setup_swap_if_needed

# Очищаем системные логи и настраиваем хранение только в RAM
journalctl --vacuum-time=1d --no-pager >/dev/null 2>&1
find /var/log -maxdepth 1 -type f -name "*.log" -exec truncate -s0 {} \; 2>/dev/null || true
if ! grep -q '^Storage=volatile' /etc/systemd/journald.conf; then
    sed -i 's/^#Storage=.*/Storage=volatile/' /etc/systemd/journald.conf
    systemctl restart systemd-journald
fi

# Устанавливаем ядро Xray
bash -c "$(curl -4 -L https://github.com/XTLS/Xray-install/raw/main/install-release.sh)" @ install
[ -f /usr/local/etc/xray/.keys ] && rm /usr/local/etc/xray/.keys
touch /usr/local/etc/xray/.keys
echo "shortsid: $(openssl rand -hex 8)" >> /usr/local/etc/xray/.keys
echo "uuid: $(xray uuid)" >> /usr/local/etc/xray/.keys
xray x25519 >> /usr/local/etc/xray/.keys

export uuid=$(cat /usr/local/etc/xray/.keys | awk -F': ' '/uuid/ {print $2}')
export privatkey=$(cat /usr/local/etc/xray/.keys | awk -F': ' '/PrivateKey/ {print $2}')
export shortsid=$(cat /usr/local/etc/xray/.keys | awk -F': ' '/shortsid/ {print $2}')

# Финальная конфигурация Xray  VLESS + Reality + Vision с DoH Cloudflare маскировкой (obfuscation)
cat << EOF > /usr/local/etc/xray/config.json
{
    "log": {
        "loglevel": "warning",
        "dnsLog": false,
        "access": "none"
    },
    "dns": {
        "servers": [
            "1.1.1.1",
            "8.8.8.8",
            {
                "address": "1.1.1.1",
                "port": 53,
                "domains": [
                    "geosite:cn"
                ],
                "expectIPs": [
                    "geoip:cn"
                ]
            },
            {
                "address": "localhost",
                "skipFallback": true
            }
        ],
        "queryStrategy": "UseIPv4",
        "disableCache": false,
        "hosts": {
            "geo.prod.do.dsp.mp.microsoft.com": "127.0.0.1",
            "www.msftconnecttest.com": "127.0.0.1",
            "ctldl.windowsupdate.com": "127.0.0.1",
            "edge.microsoft.com": "127.0.0.1",
            "telemetry.microsoft.com": "127.0.0.1",
            "watson.telemetry.microsoft.com": "127.0.0.1",
            "telemetry.google.com": "127.0.0.1",
            "google-analytics.com": "127.0.0.1",
            "stats.g.doubleclick.net": "127.0.0.1"
        }
    },
    "routing": {
        "domainStrategy": "IPIfNonMatch",
        "rules": [
            {
                "type": "field",
                "port": 53,
                "outboundTag": "direct"
            },
            {
                "type": "field",
                "ip": [
                    "1.1.1.1",
                    "8.8.8.8",
                    "1.0.0.1",
                    "8.8.4.4"
                ],
                "outboundTag": "direct"
            },
            {
                "type": "field",
                "domain": [
                    "domain:geo.prod.do.dsp.mp.microsoft.com",
                    "domain:www.msftconnecttest.com",
                    "domain:telemetry.microsoft.com",
                    "domain:telemetry.google.com"
                ],
                "outboundTag": "block"
            },
            {
                "type": "field",
                "domain": ["geosite:category-ads-all"],
                "outboundTag": "block"
            },
            {
                "type": "field",
                "domain": ["geosite:cn", "geosite:ru"],
                "outboundTag": "direct"
            },
            {
                "type": "field",
                "ip": ["geoip:cn", "geoip:ru", "geoip:private"],
                "outboundTag": "direct"
            },
            {
                "type": "field",
                "protocol": ["bittorrent"],
                "outboundTag": "block"
            }
        ]
    },
    "inbounds": [
        {
            "listen": "0.0.0.0",
            "port": 443,
            "protocol": "vless",
            "settings": {
                "clients": [
                    {
                        "email": "main",
                        "id": "$uuid",
                        "flow": "xtls-rprx-vision"
                    }
                ],
                "decryption": "none"
            },
            "streamSettings": {
                "network": "tcp",
                "security": "reality",
                "realitySettings": {
                    "show": false,
                    "dest": "www.cloudflare.com:443",
                    "xver": 0,
                    "serverNames": [
                        "www.cloudflare.com",
                        "cloudflare.com",
                        "api.cloudflare.com"
                    ],
                    "privateKey": "$privatkey",
                    "minClientVer": "",
                    "maxClientVer": "",
                    "maxTimeDiff": 0,
                    "shortIds": [
                        "$shortsid"
                    ]
                }
            },
            "sniffing": {
                "enabled": true,
                "destOverride": [
                    "http",
                    "tls"
                ],
                "routeOnly": true
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "freedom",
            "tag": "direct",
            "settings": {
                "domainStrategy": "UseIP"
            }
        },
        {
            "protocol": "blackhole",
            "tag": "block",
            "settings": {
                "response": {
                    "type": "none"
                }
            }
        }
    ],
    "policy": {
        "levels": {
            "0": {
                "handshake": 2,
                "connIdle": 300,
                "uplinkOnly": 1,
                "downlinkOnly": 1
            }
        },
        "system": {
            "statsInboundUplink": false,
            "statsInboundDownlink": false
        }
    }
}
EOF

# Исполняемый файл для создания mainuser
cat << 'EOF' > /usr/local/bin/mainuser
#!/bin/bash
protocol=$(jq -r '.inbounds[0].protocol' /usr/local/etc/xray/config.json)
port=$(jq -r '.inbounds[0].port' /usr/local/etc/xray/config.json)
uuid=$(cat /usr/local/etc/xray/.keys | awk -F': ' '/uuid/ {print $2}')
pbk=$(cat /usr/local/etc/xray/.keys | awk -F': ' '/Password/ {print $2}')
sid=$(cat /usr/local/etc/xray/.keys | awk -F': ' '/shortsid/ {print $2}')
sni=$(jq -r '.inbounds[0].streamSettings.realitySettings.serverNames[0]' /usr/local/etc/xray/config.json)
ip=$(timeout 3 curl -4 -s icanhazip.com)

link="$protocol://$uuid@$ip:$port?security=reality&sni=$sni&fp=firefox&pbk=$pbk&sid=$sid&spx=/&type=tcp&flow=xtls-rprx-vision&encryption=none#main"

echo ""
echo "Ссылка для подключения:"
echo "$link"
echo ""
echo "QR-код:"
echo "$link" | qrencode -t ansiutf8
EOF
chmod +x /usr/local/bin/mainuser

# Исполняемый файл для создания новых клиентов
cat << 'EOF' > /usr/local/bin/adduser
#!/bin/bash
read -p "Введите имя пользователя (email): " email

if [[ -z "$email" || "$email" == *" "* ]]; then
    echo "Имя пользователя не может быть пустым или содержать пробелы. Попробуйте снова."
    exit 1
fi

user_json=$(jq --arg email "$email" '.inbounds[0].settings.clients[] | select(.email == $email)' /usr/local/etc/xray/config.json)

if [[ -z "$user_json" ]]; then
    uuid=$(xray uuid)
    jq --arg email "$email" --arg uuid "$uuid" '.inbounds[0].settings.clients += [{"email": $email, "id": $uuid, "flow": "xtls-rprx-vision"}]' /usr/local/etc/xray/config.json > tmp.json && mv tmp.json /usr/local/etc/xray/config.json
    systemctl restart xray
    index=$(jq --arg email "$email" '.inbounds[0].settings.clients | to_entries[] | select(.value.email == $email) | .key'  /usr/local/etc/xray/config.json)
    protocol=$(jq -r '.inbounds[0].protocol' /usr/local/etc/xray/config.json)
    port=$(jq -r '.inbounds[0].port' /usr/local/etc/xray/config.json)
    uuid=$(jq --argjson index "$index" -r '.inbounds[0].settings.clients[$index].id' /usr/local/etc/xray/config.json)
    pbk=$(cat /usr/local/etc/xray/.keys | awk -F': ' '/Password/ {print $2}')
    sid=$(cat /usr/local/etc/xray/.keys | awk -F': ' '/shortsid/ {print $2}')
    username=$(jq --argjson index "$index" -r '.inbounds[0].settings.clients[$index].email' /usr/local/etc/xray/config.json)
    sni=$(jq -r '.inbounds[0].streamSettings.realitySettings.serverNames[0]' /usr/local/etc/xray/config.json)
    ip=$(curl -4 -s icanhazip.com)
    
    link="$protocol://$uuid@$ip:$port?security=reality&sni=$sni&fp=firefox&pbk=$pbk&sid=$sid&spx=/&type=tcp&flow=xtls-rprx-vision&encryption=none#$username"
    
    echo ""
    echo "Ссылка для подключения:"
    echo "$link"
    echo ""
    echo "QR-код:"
    echo "$link" | qrencode -t ansiutf8
else
    echo "Пользователь с таким именем уже существует. Попробуйте снова." 
fi
EOF
chmod +x /usr/local/bin/adduser

# Исполняемый файл для удаления клиентов
touch /usr/local/bin/rmuser
cat << 'EOF' > /usr/local/bin/rmuser
#!/bin/bash
emails=($(jq -r '.inbounds[0].settings.clients[].email' "/usr/local/etc/xray/config.json"))

if [[ ${#emails[@]} -eq 0 ]]; then
    echo "Нет клиентов для удаления."
    exit 1
fi

echo "Список клиентов:"
for i in "${!emails[@]}"; do
    echo "$((i+1)). ${emails[$i]}"
done

read -p "Введите номер клиента для удаления: " choice

if ! [[ "$choice" =~ ^[0-9]+$ ]] || (( choice < 1 || choice > ${#emails[@]} )); then
    echo "Ошибка: номер должен быть от 1 до ${#emails[@]}"
    exit 1
fi

selected_email="${emails[$((choice - 1))]}"

jq --arg email "$selected_email" \
   '(.inbounds[0].settings.clients) |= map(select(.email != $email))' \
   "/usr/local/etc/xray/config.json" > tmp && mv tmp "/usr/local/etc/xray/config.json"

systemctl restart xray

echo "Клиент $selected_email удалён."
EOF
chmod +x /usr/local/bin/rmuser

# ДОБАВИТЬ В КОНЕЦ СКРИПТА:
cat << 'EOF' > /usr/local/bin/listuser
#!/bin/bash
emails=($(jq -r '.inbounds[0].settings.clients[].email' "/usr/local/etc/xray/config.json"))
if [[ ${#emails[@]} -eq 0 ]]; then
    echo "Список клиентов пуст"
    exit 1
fi
echo "Список клиентов:"
for i in "${!emails[@]}"; do
    echo "$((i+1)). ${emails[$i]}"
done
EOF
chmod +x /usr/local/bin/listuser

# Исполняемый файл для вывода списка пользователей и создания ссылок
cat << 'EOF' > /usr/local/bin/sharelink
#!/bin/bash
emails=($(jq -r '.inbounds[0].settings.clients[].email' /usr/local/etc/xray/config.json))

for i in "${!emails[@]}"; do
   echo "$((i + 1)). ${emails[$i]}"
done

read -p "Выберите клиента: " client

if ! [[ "$client" =~ ^[0-9]+$ ]] || (( client < 1 || client > ${#emails[@]} )); then
    echo "Ошибка: номер должен быть от 1 до ${#emails[@]}"
    exit 1
fi

selected_email="${emails[$((client - 1))]}"

index=$(jq --arg email "$selected_email" '.inbounds[0].settings.clients | to_entries[] | select(.value.email == $email) | .key'  /usr/local/etc/xray/config.json)
protocol=$(jq -r '.inbounds[0].protocol' /usr/local/etc/xray/config.json)
port=$(jq -r '.inbounds[0].port' /usr/local/etc/xray/config.json) 
uuid=$(jq --argjson index "$index" -r '.inbounds[0].settings.clients[$index].id' /usr/local/etc/xray/config.json)
pbk=$(cat /usr/local/etc/xray/.keys | awk -F': ' '/Password/ {print $2}')
sid=$(cat /usr/local/etc/xray/.keys | awk -F': ' '/shortsid/ {print $2}')
username=$(jq --argjson index "$index" -r '.inbounds[0].settings.clients[$index].email' /usr/local/etc/xray/config.json)
sni=$(jq -r '.inbounds[0].streamSettings.realitySettings.serverNames[0]' /usr/local/etc/xray/config.json)
ip=$(curl -4 -s icanhazip.com)

link="$protocol://$uuid@$ip:$port?security=reality&sni=$sni&fp=firefox&pbk=$pbk&sid=$sid&spx=/&type=tcp&flow=xtls-rprx-vision&encryption=none#$username"

echo ""
echo "Ссылка для подключения:"
echo "$link"
echo ""
echo "QR-код:"
echo "$link" | qrencode -t ansiutf8
EOF
chmod +x /usr/local/bin/sharelink

systemctl restart xray

echo "Xray-core успешно установлен"
mainuser

# Создаем файл с подсказками
touch $HOME/help
cat << 'EOF' > $HOME/help

Команды для управления пользователями Xray:

    mainuser - выводит ссылку для подключения основного пользователя
    adduser - создает нового пользователя
    rmuser - удаление пользователей
    sharelink - выводит список пользователей и позволяет создать для них ссылки для подключения
    listuser - выводит список клиентов

Файл конфигурации находится по адресу:

    /usr/local/etc/xray/config.json

Команда для перезагрузки ядра Xray:

    systemctl restart xray

Текущая конфигурация: VLESS + REALITY + Vision
Маскировка под: www.cloudflare.com
DNS: Cloudflare DoH (https://1.1.1.1/dns-query)

Особенности конфигурации:
- DNS через DoH для шифрования запросов
- Разделение трафика (китайские сайты идут напрямую)
- Блокировка рекламы и BitTorrent
- Sniffing для определения доменов

EOF
